==================================================
ğŸ” Code Review Agent (Advanced)
ğŸ“ Directory: agents/code-review
==================================================

âš™ï¸  Configuration:
   Model: opus
   Output: Structured JSON
   Sub-agents: security-scanner

ğŸ”§ Glob: **/*.ts
ğŸ”§ Read: example.ts
ğŸ”§ Read: 01-basic.ts
ğŸ”§ Read: 02-simple.ts
ğŸ¤– Delegating to sub-agent: security-scanner
ğŸ”§ Grep: "password" in agents/code-review
ğŸ”§ Grep: "eval\(" in agents/code-review
ğŸ”§ Grep: "require\(" in agents/code-review

âœ… Review complete! Cost: $0.0342

==================================================
ğŸ“Š REVIEW RESULTS
==================================================

Score: 45/100
Issues Found: 5

Summary: Multiple critical issues found including off-by-one errors, missing type safety, and security vulnerabilities. The example.ts file demonstrates several common anti-patterns that should be addressed. The agent implementation files (01-basic.ts, 02-simple.ts, 03-advanced.ts) show good practices with proper error handling and type safety.

ğŸ”´ CRITICAL (2)
------------------------------

[bug] example.ts:2
  Off-by-one error in loop condition will cause array index out of bounds exception when i equals users.length
  ğŸ’¡ Change `i <= users.length` to `i < users.length`

[security] example.ts:9
  Sensitive password credential logged to console, which will expose it in logs, monitoring systems, and potentially to attackers
  ğŸ’¡ Remove the console.log statement entirely or redact sensitive data before logging with: console.log("Connecting with:", password.replace(/./g, '*'))

ğŸŸ  HIGH (2)
------------------------------

[bug] example.ts:4
  No null or undefined check before accessing user.name property, will crash if users array contains null/undefined elements
  ğŸ’¡ Add optional chaining and null coalescing: `users[i]?.name?.toUpperCase() ?? 'UNKNOWN'`

[bug] example.ts:16
  Fetch call lacks error handling for network failures, timeouts, or invalid responses. Will throw unhandled promise rejection on failure
  ğŸ’¡ Wrap in try-catch block and handle different error scenarios:
      try {
        const response = await fetch(url)
        if (!response.ok) throw new Error(`HTTP ${response.status}`)
        return response.json()
      } catch (error) {
        console.error('Fetch failed:', error)
        throw error
      }

ğŸŸ¡ MEDIUM (1)
------------------------------

[style] example.ts:13
  Missing TypeScript type annotation for url parameter reduces type safety and makes the function signature unclear
  ğŸ’¡ Add explicit type annotation: `async function fetchData(url: string): Promise<any>`
